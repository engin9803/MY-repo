## 알고리즘과 초콜릿 케이크 레시피
### 알고리즘이란
- 수학과 컴퓨터 과학, 언어학 또는 관련 분야에서 어떠한 문제를 해결하기 위해 정해진 일련의 정차나 방법을 공식화한 형태로 표현한 것.

- 알고리즘의 조건
    - 입력 : 외부에서 **제공되는 자료가 0개 이상 존재해야** 한다.
    - 출력 : 적어도 **2개 이상의 서로 다른 결과**를 내어야 한다.
    - 명확성 : 수행과정은 **무엇을 하기위한 것인지 명확하게 정의**되어야 한다.
    - 유한성 : **알고리즘의 명령어대로 수행했을 때 처리된 후 종료**되어야 한다.
    - 효율성 : 모든 과정은 **명백하게 실행(검증)가능한 것**이어야 하며, 시간적 공간적 효율성을 가져야한다.

- 알고리즘의 어원  
  9세기 페르시아의 수학자인 무하마드 알콰리즈미의 이름을 라틴어화한 algorismus<sub>알고리스무스</sub>에서 유래 되었고 수학, 천문학, 지리학을 섭렵한 당대 최고의 과학자였다.

- 좋은 알고리즘이란?  
    공간 복잡도 (space complexity) - 총 저장공간의 양  
    시간 복잡도 (time complexity) - 총 소요시간  
    공간 복잡도 - 저장공간(메모리)를 차지하느냐를 분석하는 방법  
    시간 복잡도 - 어떤 문제를 해결하는 걸리는 시간
    
- 좋은 알고리즘의 분석 기준  
    - 정확성 : 적당한 입력에 대해서 유한 시간 내에 올바른 답을 산출하는가를 판단
    - 작업량 : 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정  
    - 기억 장소 사용량 : 메모리의 사용량의 뜻으로 수행에 필요한 저장공간을 가능한 최소화했는가를 판단
    - 최적성 : 더 적은 기본연산으로 수행될 수 있는 알고리즘이 없는지 판단

자료구조란?
- 자료구조란 여러 **데이터**들의 묶음을 저장하고, 사용하는 방법을 정의
 
- 데이터(data)란?
    - 데이터는 문자, 숫자, 소리, 그림, 영상 등 실생활을 구성하고 있는 모든 값이다.  
    이름, 나이, 키, 집 주소, 목소리, 유전자 DNA까지 데이터로 분류할 수 있다.
- 데이터는 그 자체만으로 어떤 정보를 가지기 힘들다.
    - 예를 들어 나이라는 데이터만 알고 있다면, 사람의 나이인지, 강아지의 나이인지, 나무의 나이인지 알 수 없다.
- 데이터는 분석하고 정리하여 활용해야만 의미를 가질 수 있다.
- 데이터를 사용하려는 목적에 따라 형태를 구분하고, 분류하여 사용한다.
- 필요에 따라 데이터의 특징을 잘 파악(분석)하여 정리하고, 활용해야 한다  
    - 데이터를 정해진 규칙없이 저장하거나, 하나의 구조로만 정리하고 활용하는 것보다 데이터를 체계적으로 정리하여 저장해두는 게, 데이터를 활용하는 데 있어 훨씬 유리하다.

## 반에서 가장 키 큰 사람찾기: 선형 알고리즘
- 시간 복잡도를 표기하는 방법
    - 알고리즘 분석 시, 평균성능과 최악의 성능이 가장 많이 활용된다. 하지만 평균을 구하는 세타 표기법이 가장 정확한 것에 비해 알고리즘이 복잡해질수록 평가하기가 어려워서 최악을 구       하는 **빅-오 표기법**을 가장 많이 사용한다.
- Big-O(빅-오): 최악의 입력을 한 상태에서 작업 완료까지 가장 느린 시간을 측정
- Big-Ω(빅-오메가): 최적의 입력을 한 상태에서 작업을 완료하는데 가장 빠른 시간을 측정
- Big-θ(빅-세타): 여러가지 다른 경우의 수를 입력하여, 총실행시간을 계산하고 시행횟수로 나눠서 평균을 측정
- 시간 복잡도 줄이는 법
    - 알고리즘에서 시간복잡도에 가장 큰 영향을 끼치는 것은 **반복문**이다
    - 해결해야할 문제 또는 이슈에 맞는 적절한 알고리즘을 설계해야한다
    - 각 알고리즘의 형태에 맞는 효율적인 자료구조들을 이용한다면 시간 복잡도를 낮출 수 있다  
 
- 선형 탐색 알고리즘 (Linear Search Algorithm)
    - 맨 앞이나, 맨 뒤부터 순서대로 하나하나 찾아보는 알고리즘이다.
    - 가장 단순하고 간단한 탐색 알고리즘이다.
1. 맨 끝부터 하나하나 원하는 값을 찾아본다.
2. 원하는 값을 찾으면, 탐색을 종료한다.  

예시

5를 찾을 때, 맨 왼쪽에 있는 1부터 시작해서 하나씩 탐색한다.
<img src="https://user-images.githubusercontent.com/74358273/170695234-1c2b236b-7228-47a8-97e2-9d862e781426.png" width="100%" height="100%"/>
<img src="https://user-images.githubusercontent.com/74358273/170694958-1c84c052-16ce-47c0-8827-ddf060936e36.png" width="100%" height="100%"/>

시간 복잡도
길이 n짜리의 리스트를 탐색할 때,

- 최선의 경우
    - 리스트의 첫 번째 원소가 정답인 경우
- 최악의 경우
    - 리스트의 맨 마지막 원소가 정답이거나, 리스트에 정답이 없을 때

O(n)의 시간복잡도를 가진다.

   선형 알고리즘 O(n): 직선적 시간
    
<img src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F45bc1d05-6d3f-4310-a7df-7581033d7e55%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC39.jpg" width="100%" height="100%"/>

모든 입력값을 적어도 한 번 이상을 살펴보기 때문에 입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다.  
**ex) for문, 최대값, 최소값**
