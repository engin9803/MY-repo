## - 스코프, 호이스팅, TDZ
- ### 스코프  
    현재 실행되는 컨텍스트를 말한다. 여기서 `컨텍스트는 값과 표현식이 "표현"되거나 참조 될 수 있음을 의미`한다. 만약 변수 또는 다른 표현식이 "해당 스코프"내에 있지 않다면 사용할 수 없다.  
    스코프는 또한 계층적인 구조를 가지기 때문에 하위 스코프는 상위 스코프에 접근할 수 있지만 반대는 불가하다.  
    `함수는 자바스크립트에서 클로저 역할`을 하기 때문에 스코프를 생성하므로 함수 내에 정의된 변수는 외부 함수나 다른 함수 내에서는 접근 할 수 없다.
- ### 호이스팅  
    `인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다.` `var로` 선언한 변수의 경우 호이스팅 시 `undefined`로 변수를 초기화한다. 반면 `let`과 `const`로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않는다.  
    호이스팅을 설명할 땐 주로 `"변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮기는"` 것으로 말하곤 한다. 따라서 변수를 정의하는 코드보다 사용하는 코드가 앞서 등장할 수 있습니다. 다만 `선언과 초기화를 함께 수행하는 경우`, 선언 코드까지 실행해야 변수가 초기화된 상태가 됨을 주의해야한다.
- ### TDZ 시간상 사각지대"(Temporal Dead Zone, TDZ) 
    `let 변수`는 초기화하기 전에는 읽거나 쓸 수 없습니다(선언 구문에 초기 값을 지정하지 않은 경우 undefined로 초기화함). 초기화 전에 접근을 시도하면 ReferenceError가 발생합니다.  
    **"시간상" 사각지대인 이유**는, 사각지대가 `코드의 작성 순서(위치)`가 아니라 `코드의 실행 순서(시간)에 의해 형성`되기 때문입니다.
    변수 스코프의 맨 위에서 변수의 초기화 완료 시점까지의 변수는 "시간상 사각지대"(Temporal Dead Zone, TDZ)에 들어간 변수라고 표현합니다.
- 함수 선언문과 함수 표현식에서 호이스팅 방식의 차이  
    - **함수 선언식은**  
    1. 코드가 실행되기 전에 로드  
    2. 호이스팅 가능
    - **함수 표현식은**  
    1. 호이스팅 되지 않으므로 정의된 범위에서 로컬 변수의 복사본을 유지가능  
    2. 인터프리터가 해당 코드 줄에 도달할 때 로드된다.  
```js
// 선언 전에 호출되도 정상 동작된다
// 1
console.log(enchovy());x
function enchovy() {
    return 1;
}
```
때문에 함수 선언식은 블록문 밖에서 호출이 가능하다. 
```js
 // 로드되지 않아 error 발생
console.log(enchovy());
const enchovy = function() {
    return 1;
}
```
함수 표현식은 선언한 변수에 할당하는지에 따라 스코프가 달라진다.
- ## 여러분이 많이 작성해온 let, const, var, function 이 어떤 원리로 실행되는지 알 수 있어요.
    - var, let, const, function  
    1. 값을 저장하는 것을 할당(assignment, 대입, 저장)  
    2. 변수에 저장된 값을 읽어 들이는 것을 참조(reference)  
    3. 변수명을 자바스크립트 엔진에 알리는 것을 선언(declaration)이라 한다.

    - 변수 선언은 선언 → 초기화 단계를 거쳐 수행된다.  
    1. 선언 단계: 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.  
    2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다.
- ## 실행 컨텍스트와 콜 스택
- 실행 컨텍스트
    1. scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다. 실행 컨텍스트를 바로 이해하지 못하면 코드 독해가 어려워지며 디버깅도 매우 곤란해 질 것이다.  
    실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 좀 더 쉽게 말하자면 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경이다. 여기서 말하는 실행 가능한 코드는 아래와 같다.

    - 전역 코드 : 전역 영역에 존재하는 코드
    - Eval 코드 : eval 함수로 실행되는 코드
    - 함수 코드 : 함수 내에 존재하는 코드  
    일반적으로 실행 가능한 코드는 `전역 코드`와 `함수 내 코드`이다.

    1. 변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티 
    2. 함수 선언
    3. 변수의 유효범위(Scope)
    4. this

    이와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다
    
- 콜 스택  
    자바스크립트는 단일 스레드 프로그래밍 언어이고, 단일 호출 스택방식이다.  
    단일 호출 스택은 한 번에 하나의 일(Task)만 처리할 수 있다.  
    호출 스택이란 프로그램에서 우리가 어디에 있는지를 기본적으로 기록하는 데이터 구조이며 동작 방식은 다음과 같다.  
    함수를 실행하면 해당 함수의 기록을 스택 맨 위에 추가(Push) 후 우리가 함수를 결과 값을 반환하면 스택에 쌓여있던 함수는 제거(Pop)가 된다.
    ```js
    function multiply(x, y) {   // Stap 1, 2
    return x * y;               // Stap 2를 값을 구하고 반환
    }
    function printSquare(x) {    
    var s = multiply(x, x);     
    console.log(s);             // Stap 1, 3
    }
    printSquare(5);         //  Stap 1  // Stap 4
    ```
    엔진이 이 코드를 실행하기 전에는 호출 스택이 비어있습니다. 가장 아랫줄에 printSquare 함수가 실행되면 이후 단계는 다음과 같습니다  
    <img width="1000" alt="9995544C5C32151627" src="https://user-images.githubusercontent.com/74358273/169210296-fb2faef0-9e62-427b-a203-9b77d969e997.png">  
    호출 스택의 각 항목을 스택 프레임이라고 합니다.
- ## 스코프 체인, 변수 은닉화
- 스코프 체인
    자바스크립트의 모든 코드는 스코프 체인을 갖고 있다. 스코프 체인은 해당 코드의 유효 범위(in scope) 안에 있는 변수를 정의하는 객체의 체인, 리스트다.  
    자바스크립트가 변수 값을 얻으려고 할 때(variable resolution, 변수 해석) 스코프 체인에서 변수를 찾는다.  
    - 스코프 체인은 객체의 리스트  
    첫 번째 객체에서 해당 변수를 찾고, 없으면 그 다음 객체에서 해당 변수를 찾고, 여기도 없으면 그 다음 객체에서 찾는 식이다. 리스트의 끝까지 탐색했는데도 그 변수가 없다면 `reference error`가 발생하는 것이다.  
    최상위 자바스크립트 코드(어떠한 함수에도 속하지 않는 코드)의 스코프 체인에는 하나의 객체만 있고, 그것이 전역 객체이다.  
    중첩되지 않은 함수의 스코프 체인은 2개의 객체로 이루어진다. 하나는 함수의 매개변수와 지역 변수를 정의하는 객체고, 다른 하나는 전역 객체다.  
    함수가 정의될 때, 함수는 스코프 체인을 저장한다.  
    함수가 호출될 때, 함수는 지역 변수를 보관하는 새로운 객체를 만들고 그 객체를 기존에 만들어둔 스코프 체인에 추가한다.

- 변수 은닉화 (Variable Shadowing)  
이름이 같은 두 변수 중 local scope에 있는 변수가 바깥 scope에 있는 변수를 "shadow"한다. 즉 덮어쓴다.
```js
const symbol = '¥';         // 전역 symbol

function displayPrice(price) {
  const symbol = '$';       // 지역 symbol
  console.log(symbol + price);
}

displayPrice('80');
// '$80'  // 스코프 체인으로 지역 -> 전역 순서로 주소를 찾아서 출력하여 지역 Symbol로 전역 Symbol을 덮어씌어서('shadow') 출력
```
전역 변수로 symbol이 있고 `'¥'`이 할당되어 있는데, `displayPrice()` 함수 내에 전역 변수와 같은 symbol이라는 변수가 있고 `'$'`라는 다른 값이 할당되어 있다.  
`displayPrice()` 함수를 호출하면 `'$'` 가 적용된 값이 출력된다. `'$'`를 가리키는 symbol이 함수 내부에 선언되어 있으므로, 바깥 scope에 있는 모든 symbol들은 다 무시한다. 그래서 `'$'`가 적용된 것이다.  
각각 다른 context에서 같은 이름의 변수들이 선언되어 있을 경우, 안쪽에서 바깥쪽 scope로의 scope chain에서 가장 먼저 찾아지는 값을 쓰게 된다. 즉 같은 이름을 가진 **모든 지역변수**는 **바깥 scope의 변수에 비해 `항상 우선순위`**를 갖는다.
