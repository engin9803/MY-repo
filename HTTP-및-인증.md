- HTTP 인증에 대해서 공부하고, 어떤 인증 유형이 있는지 정리해보기(유형별로 동작 원리까지 정리하면 완전
## HTTP 응답
HTTP 응답은 HTTP 요청에 대한 결과를 반환하는 메시지다 
- 상태 정보(Status)
    - 요청을 수행했는지, 하지 않았는지, 안 했다면 이유는 무엇인지를 나타낸다
    - 클라이언트에게 전송할 리소스가 응답에 포함된다

## 시작 줄
- HTTP 응답의 시작 줄은 
 - HTTP 버전
    - 상태 코드(Status Code)
        - 요청에 대한 처리 결과를 세 자릿수로 나타낸다
        - 요청을 처리한 결과
    - 처리 사유(Reason Phrase)
        - 상태 코드가 발생한 이유
    - 각각은 띄어쓰기로 구분된다

- HTTP 버전은 서버에서 사용하는 HTTP 프로토콜의 버전을 나타낸다
- 상태 코드는 요청에 대한 처리 결과를 세 자릿수로 나타낸다 
- HTTP 표준인 RFC 2616은 대략 40여개의 상태 코드를 정의하고 있는데, 각각은 첫 번째 자릿수에 따라 5개의 클래스로 분류된다 

## 처리 사유
상태코드|설명|대표 예시
:-|:-|:-|
1xx|요청을 제대로 받았고, 처리가 진행 중임|          |
2xx|요청이 제대로 처리됨                  |200 : 성공|
3xx|요청을 처리하려면, 클라이언트가 추가 동작을 취해야 함|302 : 다른 URL로 갈 것
4xx|클라이언트가 잘못된 요청을 보내어 처리에 실패했습니다|400 : 요청이 문법에 맞지 않음</br>403 : 클라이언트가 리소스에 요청할 권한이 없음</br>404 : 리소스가 없음|
5xx|클라이언트의 요청은 유효하지만, 서버에 에러가 발생하여 처리에 실패했습니다|500 : 요청을 처리하다가 에러가 발생함</br>503 : 서버가 과부하로 인해 요청을 처리할 수 없음

- HTTP(HyperText Transfer Protocol): 웹 서버와 클라이언트가 리소스를 교환하기 위해 사용하는 **프로토콜** 클라이언트가 요청하면, 서버가 응답하는 방식
- HTTP 메시지: HTTP 서버와 클라이언트가 교환하는 데이터. 헤드와 바디로 구성되며, 각 줄은 CRLF로 구분됨
    - 헤드: 메시지에 대한 정보. 헤드의 끝에는 CRLF가 한 줄 있음
    - 바디: 클라이언트가 서버에게, 또는 서버가 클라이언트에게 전달할 데이터
- HTTP 요청(Request): 클라이언트가 서버에게 특정 동작을 요청하는 메시지
- 메소드(Method): 요청 URI가 가리키는 리소스에 대해, 서버가 수행했으면 하는 동작을 지정
- 요청 URI(Request-URI): 메소드의 대상이 되는 리소스를 지정
- HTTP 응답(Response): 요청을 처리한 결과 및 이유, 그리고 클라이언트에 전송할 웹 리소스를 포함하는 메시지
- HTTPS(HTTP on Secure socket layer): TLS를 이용하여 HTTP의 약점을 보완한 프로토콜

- HTTP 인증
    - 컴퓨터는 모니터 앞에 사람이 누구인지 알 수가 없다 그렇기 때문에 아래의 요소들을 이용하여 인증을 사용하고 있다
```
패스워드 : 본인만이 알고 있는 문자열
원타임 토큰 : 본인만이 가지고 있는 기기 등에 표시되는 한 번 쓰고 버리는 패스워드 등의 정보
전자 증명서 : 본인(단말기)이 가지고 있는 정보
바이오 매트릭스 : 지문이나 홍채 등 본인의 신체정보
IC 카드 등 : 본인만이 가지고 있는 정보
```
## HTTP에서 사용하는 인증 방법
HTTP/1.1에서 이용할 수 있는 인증방식은 아래와 같다
- 익명
    - 익명 요청은 인증정보를 포함하지 않는 요청을 말하며 리소스에 대한 모든 액세스 권한을 부여하는 것과 같다

- BASIC 인증
    - 기본 인증은 클라이언트에 대한 사용자 이름과 암호를 Base64로 인코딩 된 문자열을 보낸다
    - 간편하며 널리 쓰이나 패킷 도청에 취약하다
    - 리소스 보안을 강하게 해야 할 경우 다른 인증방식을 사용하는 것이 좋다

- DIGEST 인증
    - 사용자명, 패스워드 등을 조합하여 MD5 값으로 인증한다
    - 기본 인증보다 보안이 강화된 인증방식이다
```
1. 클라이언트 - 페이지 요청
2. 서버 - digest 인증 필요하다고 통보
3. 클라이언트 - 사용자가 아이디/패스워드 입력하면, 서버정보+클라이언트 정보 병합 후 
```
- MD5로 암호화 하여 전송
Digest 인증방식에서 서버는 클라이언트로 단순히 패스워드를 받는것이 아니고 조합된 MD5로 해시된 값을 받는다

- MD5란? (Message-Digest algorithm 5)
    - 128비트 암호화 해시함수
    - 암호화, 체크섬 무결성 검사 등에 사용된다.
    - 임의의 길이 문자열 입력 -> 128비트 문자열 출력
```
[root@zetawiki ~]# echo -n 'hello world' | md5sum 
5eb63bbbe01eeed093cb22bb8f5acdc3 -
-> 16진수 문자열로는 32자
```
- SSL 클라이언트 인증
    - 유저 ID와 패스워드를 사용한 인증방식은 이 두가지 정보가 정확하다면 본인으로서 인증할 수 있으며 이 정보가 도난됐을 때 제 3자가 접근을 할 수 있다
이를 방지하기 위한 대책중의 하나가 바로 이 **SSL 클라이언트 인증**이다
    - HTTPS의 클라이언트 인증서를 사용하여 인증하는 방식이다

    - SSL클라이언트 인증의 경우 단독으로 사용되지 않고 폼베이스 인증과 합쳐져서 이용되고 있다  
    단점으로 클라이언트 증명서 구입비용 혹은 서버의 운영자 자신이 인증 기관을 만들어서 **안전하게 운영하기 위해 들어가는 비용 등이 매우 많이 필요**하다

- 폼 베이스 인증
    - 인증의 대부분은 폼 베이스 인증이다
    - HTTP가 표준으로 제공하는 BASIC, DIGEST인증은 사용상의 문제, 보안적인 문제로 거의 사용되고 있지 않는다.
    - SSL클라이언트 인증도 도입 비용이나 운용비용의 문제로 거의 사용하고 있지 않다

- 폼 베이스 인증은 HTTP 프로토콜로서 사양이 정의되어 있는 인증 방식이 아니다
    - 클라이언트가 자격 정보를 송신하여 검증 결과에 따라 인증을 하는 방식이다 그래서 웹 애플리케이션 마다 제공되는 인터페이스나 인증의 방법이 다양하다.

폼 베이스 인증의 경우 기능 구현에 대한 표준적인 문서 등이 존재하지 않기 때문에 웹 애플리케이션에서 **제각각 구현하는 폼 베이스 인증을 사용**해야 한다
공통 사양이 없기 때문에 웹 사이트별로 다르게 구현하고 있으며, 안전한 방법으로 구현 시 높은 보안 등급을 유지할 수 있지만 문제있는 구조를 사용하고있는 웹사이트도 종종 발견할 수 있다.

- 표준적인 사양이 없으나 일반적으로 **세션관리를 위해 쿠키를 사용**하고 있다
- HTTP는 스테이트리스 프로토콜이기 때문에 방금 전 인증성공 유저라는 상태를 프로토콜 레벨에서는 유지할 수 없다 **즉 상태관리가 안되기 때문에 유저 구분을 위해서 세션 관리와 쿠키를 사용**하고 있다

HTTP 응답에 대해 더 자세한 내용은 https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html에서 표준 문서를 확인
참고 : msdn, https://blog.sonim1.com/100  